<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pertemuan 6: Algoritma Pewarnaan Bidang</title>
    <link rel="stylesheet" href="/style.css" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0"
    />
  </head>
  <body>
    <button class="sidebar-menu-button">
      <span class="material-symbols-rounded">menu</span>
    </button>

    <aside class="sidebar">
      <header class="sidebar-header">
        <a href="#" class="header-logo">
          <video autoplay loop muted playsinline class="logo-video-square">
            <source src="/assets/src/logo.mp4" type="video/mp4" />
          </video>
          <video autoplay loop muted playsinline class="logo-video-landscape">
            <source src="/assets/src/logo2.mp4" type="video/mp4" />
          </video>
        </a>
        <button class="sidebar-toggler">
          <span class="material-symbols-rounded">chevron_left</span>
        </button>
      </header>

      <div class="page-header">
        <span class="user-name">Maulana Dwi Prasetya | 241011400102</span>
      </div>

      <nav class="sidebar-nav">
        <ul class="nav-list primary-nav">
          <li class="nav-item">
            <a href="/index.html" class="nav-link">
              <span class="material-symbols-rounded">dashboard</span>
              <span class="nav-label">Dashboard</span>
            </a>
            <ul class="dropdown-menu">
              <li class="nav-item">
                <a class="nav-link dropdown-title">Dashboard</a>
              </li>
            </ul>
          </li>
          <li class="nav-item dropdown-container" id="auto-tugas-dropdown"></li>
        </ul>
      </nav>
    </aside>

    <div class="container">
      <h1>Pertemuan 6: Algoritma Pewarnaan Bidang</h1>

      <div class="card">
        <h2>Pengertian Pewarnaan Bidang</h2>
        <p>
          <strong>Pewarnaan bidang</strong> adalah proses pemberian warna pada
          elemen-elemen graf (simpul, sisi, atau region) sehingga dua elemen
          yang saling bertetangga tidak memiliki warna yang sama. Pewarnaan ini
          sangat penting dalam teori graf, karena banyak permasalahan nyata
          seperti penjadwalan, pewarnaan peta, dan penyimpanan bahan kimia
          berbahaya dapat dimodelkan dengan konsep ini.
        </p>
        <p>
          Salah satu algoritma yang populer digunakan adalah
          <strong>algoritma Welch-Powell</strong>, yang memberi warna pada
          simpul berdasarkan urutan derajat tertinggi, memastikan bahwa warna
          yang digunakan seminimal mungkin namun tetap memenuhi syarat bahwa
          simpul bertetangga tidak memiliki warna sama.
        </p>
      </div>
    </div>
    <div class="container">
      <div class="card">
      <h2>Pengertian & Rumus Pewarnaan Bidang</h2>
      <p>
        <strong>Pewarnaan bidang</strong> dalam teori graf adalah pemberian
        warna pada elemen graf (simpul, sisi, atau wilayah) sedemikian sehingga
        dua elemen yang bertetangga tidak memiliki warna yang sama. Yang paling
        umum adalah pewarnaan simpul, di mana dua simpul yang terhubung langsung
        (bertetangga) harus diberi warna berbeda.
      </p>
      <p>
        Permasalahan utama adalah menemukan jumlah warna minimum (disebut
        <strong>bilangan kromatik</strong>, <em>chromatic number</em>) yang
        diperlukan untuk mewarnai graf tersebut.
      </p>
      </div>
    </div>

    <div class="container">
      <div class="card">
      <h2>Algoritma Welch-Powell</h2>
      <ol>
        <li>
          <strong>Urutkan</strong> simpul-simpul graf menurut derajat (jumlah
          tetangga), mulai dari derajat tertinggi ke terendah.
        </li>
        <li>
          <strong>Warnai</strong> simpul dengan derajat tertinggi menggunakan
          warna pertama.
        </li>
        <li>
          <strong>Berikan warna yang sama</strong> pada simpul lain yang belum
          diwarnai, asal tidak bertetangga dengan simpul yang sudah diberi warna
          tersebut.
        </li>
        <li>
          <strong>Ulangi</strong> langkah 2-3 dengan warna baru untuk
          simpul-simpul yang tersisa, hingga seluruh simpul terwarnai.
        </li>
      </ol>
      <p>
        <strong>Rumus:</strong> Jika <em>G</em> adalah graf dengan himpunan
        simpul <em>V</em>, maka pewarnaan adalah fungsi
        <code>f: V → {1,2,...,k}</code> sedemikian sehingga
        <code>f(u) ≠ f(v)</code> untuk setiap sisi <code>uv</code> pada graf.
      </p>
      <p>
        <strong>Bilangan kromatik</strong> (χ(G)) adalah jumlah warna minimum
        yang dibutuhkan:
        <br />
        <code>χ(G) = jumlah warna minimum pada graf G</code>
      </p>
      </div>
    </div>

    <div class="container">
      <div class="card">
      <h2>Contoh Pewarnaan (Sederhana)</h2>
      <ul>
        <li>
          <strong>Pewarnaan pada graf sederhana:</strong>
          <br />
          <img
            src="/assets/src/graf-pewarnaan.png"
            alt="Contoh graf"
            style="max-width: 180px; margin: 10px 0"
          />
          <br />
          Misal urutan derajat: v1(5), v4(4), v5(4), v6(4), v2(3), v3(3),
          v7(3)<br />
          Pewarnaan: v1=a, v4=b, v5=c, v6=c, v2=b, v3=d, v7=a<br />
          Maka χ(G) = 4 (dibutuhkan 4 warna untuk graf ini)
        </li>
      </ul>
      </div>
    </div>

    <div class="container">
      <h1>Pewarnaan Simpul dengan Welch-Powell</h1>

      <div class="card">
        <h2>Masukkan Graf</h2>
        <textarea id="inputGraph" rows="5" style="width: 100%">
{ "A": ["B", "C", "D"], "B": ["A", "C"], "C": ["A", "B", "D"], "D": ["A", "C"] }</textarea
        >
        <button onclick="colorAndDrawGraph()">Warnai & Gambar</button>
      </div>

      <div class="section">
        <h2>Visualisasi</h2>
        <canvas id="graphCanvas" width="600" height="600"></canvas>
        <div id="coloringResult"></div>
      </div>
    </div>

    <script src="/script.js"></script>
    <script>
      const canvas = document.getElementById("graphCanvas");
      const ctx = canvas.getContext("2d");

      function colorAndDrawGraph() {
        const graph = JSON.parse(document.getElementById("inputGraph").value);
        const vertices = Object.keys(graph);

        vertices.sort((a, b) => graph[b].length - graph[a].length);

        const colors = {};
        let currentColor = 1;

        for (const v of vertices) {
          if (colors[v]) continue;

          colors[v] = currentColor;
          for (const u of vertices) {
            if (
              !colors[u] &&
              !graph[v].includes(u) &&
              isSafeToColor(u, currentColor, colors, graph)
            ) {
              colors[u] = currentColor;
            }
          }

          currentColor++;
        }

        const output = Object.entries(colors)
          .map(([v, c]) => `<li><strong>${v}</strong>: Warna ${c}</li>`)
          .join("");
        document.getElementById(
          "coloringResult"
        ).innerHTML = `<ul>${output}</ul>`;

        drawGraph(graph, colors);
      }

      function isSafeToColor(vertex, color, colors, graph) {
        return graph[vertex].every((neighbor) => colors[neighbor] !== color);
      }

      function drawGraph(graph, colors) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const vertices = Object.keys(graph);
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 200;
        const angleStep = (2 * Math.PI) / vertices.length;

        const positions = {};
        const colorMap = [
          "#FF6B6B",
          "#4ECDC4",
          "#FFD93D",
          "#A29BFE",
          "#F79F1F",
          "#00B894",
        ];

        vertices.forEach((v, i) => {
          const angle = i * angleStep;
          const x = centerX + radius * Math.cos(angle);
          const y = centerY + radius * Math.sin(angle);
          positions[v] = { x, y };
        });

        // Draw edges
        ctx.strokeStyle = "#999";
        ctx.lineWidth = 1.5;
        for (let v of vertices) {
          for (let neighbor of graph[v]) {
            if (vertices.indexOf(v) < vertices.indexOf(neighbor)) {
              ctx.beginPath();
              ctx.moveTo(positions[v].x, positions[v].y);
              ctx.lineTo(positions[neighbor].x, positions[neighbor].y);
              ctx.stroke();
            }
          }
        }

        // Draw nodes
        vertices.forEach((v) => {
          const { x, y } = positions[v];
          ctx.beginPath();
          ctx.fillStyle = colorMap[(colors[v] - 1) % colorMap.length];
          ctx.arc(x, y, 20, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#333";
          ctx.stroke();

          ctx.fillStyle = "#fff";
          ctx.font = "16px Poppins";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(v, x, y);
        });
      }
    </script>
    <script>
      generateSidebarListTugas();
      attachSidebarEvents();
    </script>
  </body>
</html>
